<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <header>
  <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="css/stylesheet.css" media="screen">
  <h1 id="github">julmue.github.io</h1> 
  <p id="greeting">Hi, I'm <a href="#about-me">Julian Müller</a>. Welcome to my projects! </p> 
  </p>
  </header>
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#projects">Projects</a><ul>
<li><a href="#crush---interpreter-for-the-untyped-lambda-calculus">Crush - Interpreter For The Untyped Lambda Calculus</a></li>
<li><a href="#stl---interpreter-for-the-simply-typed-lambda-calculus">stl - Interpreter For The Simply Typed Lambda Calculus</a></li>
<li><a href="#clank---theorem-prover-paraconsistent-propositional-logics">Clank - Theorem Prover (Paraconsistent Propositional Logics)</a></li>
<li><a href="#various-type-checkers-for-typed-lambda-calculi">Various Type Checkers For Typed Lambda Calculi</a></li>
<li><a href="#sat---a-sat-solver-in-prolog">SAT - A SAT Solver In Prolog</a></li>
<li><a href="#introduction-to-the-curry-howard-isomorphism-in-haskell">Introduction To The Curry-Howard-Isomorphism In Haskell</a></li>
<li><a href="#formal-verification-in-coq">Formal Verification In Coq</a></li>
<li><a href="#laser-scanning">Laser Scanning</a></li>
</ul></li>
<li><a href="#about-me">About Me</a><ul>
<li><a href="#logics-and-computer-science">Logics And Computer Science</a></li>
<li><a href="#mechanical-engineering">Mechanical Engineering</a></li>
</ul></li>
</ul>
</div>
<h2 id="projects">Projects</h2>
<p>Here are some of the projects I am working on.</p>
<h3 id="crush---interpreter-for-the-untyped-lambda-calculus">Crush - Interpreter For The Untyped Lambda Calculus</h3>
<p><em>Crush</em> is a minimal interpreter for the untyped lambda calculus. It reads lamdba expressions from standard input and reduces them applying one of the three reduction strategies:</p>
<ol style="list-style-type: decimal">
<li>Normal-order reduction</li>
<li>Call-By-Name</li>
<li>Call-By-Value</li>
</ol>
<p>Also the reduction process can be traced.</p>
<div class="figure">
<img src="./images/onePlusOne.gif" alt="" />

</div>
<p>I will extend the interpreter with some native data types (<code>Bool</code>, <code>Int</code>, <code>Char</code>, …), and operations on these data types in the near future - Church encoding everything is intriguing but very inefficient.</p>
<p>Furthermore, runtime statistics will be implemented (number of steps, depth of formula, …).</p>
<p><a href="https://github.com/julmue/Crush">Project Page</a></p>
<h3 id="stl---interpreter-for-the-simply-typed-lambda-calculus">stl - Interpreter For The Simply Typed Lambda Calculus</h3>
<p><em>stl</em> is an interpreter for the simply typed lambda calculus (with some extensions); typing is explicit.</p>
<p>The program reads expressions from the standard input and returns their type to standard error as well as their normal form to standard output.</p>
<p><a href="https://github.com/julmue/stl">Project Page</a></p>
<h3 id="clank---theorem-prover-paraconsistent-propositional-logics">Clank - Theorem Prover (Paraconsistent Propositional Logics)</h3>
<p>A paraconsistent logic is a logic where the consequence relation is not explosive, i. e. where the law <span class="math inline">{<em>A</em>, ¬<em>A</em>}⊨<em>B</em></span> does not hold. A very good introduction to this topic can be found on the <a href="http://plato.stanford.edu/entries/logic-paraconsistent/">Stanford Encyclopedia of Philosophy</a>.</p>
<p>For mathematics, an explosive consequence relation is important. But it is a nuisance in domains where operating with sets of possibly inconsistent premisses is common, such as medical assistance systems of applications in robotics. Here, paraconsistent logics shine.</p>
<p><em>Clank</em> is a prover for various systems of paraconsistent propositional logic and also vanilla propositional logic:</p>
<ol style="list-style-type: decimal">
<li>PC: Vanilla propositional calculus</li>
<li>K3: System Kleen</li>
<li>L3: System Lucasiewicz</li>
<li>LP: System Priest</li>
<li>RM: System Routly-Meyer</li>
</ol>
<p><a href="https://github.com/julmue/Clank">Project Page</a></p>
<h3 id="various-type-checkers-for-typed-lambda-calculi">Various Type Checkers For Typed Lambda Calculi</h3>
<p>Type theory is a very deep and fundamental branch of mathematic logic and computer science. It connects category theory with constructive logics, mathematics and functional programming languages. A very good introduction about its origins and recent developments can be found <a href="http://plato.stanford.edu/entries/type-theory/">here</a>.</p>
<p>The canonical way of learning type theory is by implementing the systems presented in Benjamin Pierce’s Book <a href="https://www.cis.upenn.edu/~bcpierce/tapl/">Types and Programming languages</a>. Here is my attempt by using Haskell and the framework that <em>Crush</em> provides:</p>
<ul>
<li>Simply typed lambda calculus</li>
<li>System <span class="math inline"><em>λ</em>2</span></li>
<li>System <span class="math inline"><em>λ</em><em>ω</em></span></li>
<li>System <span class="math inline"><em>λ</em>2<em>ω</em></span></li>
<li>System <span class="math inline"><em>λ</em><em>P</em></span></li>
<li>Calculus Of Constructions</li>
</ul>
<p>I will implement each of the systems as a Church-syle lambda calculus (i.e. no type-erasure) in two variants:</p>
<ol style="list-style-type: decimal">
<li>A bare-bones version only using a minimum of primitives; this system can be regarded as a minimalistic proof assistant.</li>
<li>An extended version with support for native data types, records, variants and potentially/optionally unbound recursion.</li>
</ol>
<p>This is my favourite project for the upcoming year as there is so much more to explore!</p>
<p><a href="https://github.com/julmue/LambdaTypeCheckers">Project Page</a></p>
<h3 id="sat---a-sat-solver-in-prolog">SAT - A SAT Solver In Prolog</h3>
<p><em>SAT</em> is an acronym for the <em>satisfiability problem of classical propositional logics</em> - the problem to decide if a given formula in propositional logic has a model. The problem is decidable - but it is NP-complete.</p>
<p>A SAT solver implements an efficient decision procedure to solve the satisfiability problem. While these procedures are technically still NP-complete, most of the cases can be solved in a very short time thanks to clever heuristics that quickly shrink the solution space.</p>
<p>SAT solving is widely used in industrial applications: Many configuration and planning problems can be modeled as propositional formulas and then solved via a sat-solver. Application domains range from buildability proofs in the automotive industry to formal verification of circuit-designs relied on by semiconductor manufacturers.</p>
<p>My project contains a SAT solver for logic formulas in the DMAIC format written in the logic programming language Prolog.</p>
<p><a href="https://github.com/julmue/DpllDimacSatSolver">Project Page</a></p>
<h3 id="introduction-to-the-curry-howard-isomorphism-in-haskell">Introduction To The Curry-Howard-Isomorphism In Haskell</h3>
<p>The Curry-Howard-isomorphism is a fundamental connection between constructive logics, typed lambda calculi and category theory. It turns out, that simply typed lambda calculus and intuitionistic propositional logic are essentially the same thing, and both have a deep connection to cartesian-closed categories in category theory. This connection extends to richer logics and type theories and culminates in powerful systems like the Calculus of Constructions, which can be used as an alternative foundation for constructive mathematics. This has a lot of real-world applications especially in the domain of functional programming and proof assistants.</p>
<p>The page contains some of the fundamental theorems and mechanisms of the isomorphism implemented in the functional language Haskell.</p>
<p><a href="https://github.com/julmue/HaskellCurryHoward">Project Page</a></p>
<h3 id="formal-verification-in-coq">Formal Verification In Coq</h3>
<p>The Coq theorem prover is a proof assistance environment which is built around an implementation of the Calculus of Constructions, a very powerful type theory.</p>
<p>It is possible to encode and proof constructive mathematics and logics as well as functional programs in this calculus and extract them to general purpose functional programming languages such as Haskell and OCaml. This allows for correctness proofs of e.g. a booking algorithm in banking.</p>
<p>Here, proving is programming and programming is proving!</p>
<p>Currently I’m following up on Pierce et al <a href="https://www.cis.upenn.edu/~bcpierce/sf/current/index.html">Software Foundations</a>, a book where various programming languages are implemented and have their properties proven with the Coq theorem prover.</p>
<p><a href="https://github.com/julmue/Software-Foundations">Project Page</a></p>
<h3 id="laser-scanning">Laser Scanning</h3>
<p>As an engineer one of my specializations is technical optics and industrial image processing – For my bachelor thesis I designed and implemented a prototype laser scanner for the R&amp;D department of <a href="https://www.herrenknecht.com/en/home.html">Herrenknecht AG</a>. Its purpose is to detect the wear of tunnel-boring machine cutting-tools whilst tunneling. Data acquisition via a laser scanner is the ideal fit for this harsh environment.</p>
<div class="figure">
<img src="./images/owls.png" title="test" alt="A wooden owl scanned by a laser scanner with software implemented in MATLAB" />
<p class="caption">A wooden owl scanned by a laser scanner with software implemented in MATLAB</p>
</div>
<p>To proof that laser triangulation is a suitable measurement method for our use-case and before attempting to build the full-scale and very expensive prototype I build a simple laser-scanner from an of-the-shelf webcam and some stepper motors. The triangulation algorithm as well as the control of the stepper motors are implemented in MATLAB. The images above are the result of the first scans.</p>
<h2 id="about-me">About Me</h2>
<div class="figure">
<img src="./images/Me.png" alt="" />

</div>
<p>My name is Julian Müller and I’m a mechanical engineer / logician and functional programming enthusiast (see my CV in <a href="./files/CV_Julian_Mueller_de.pdf">german</a> or <a href="./files/CV_Julian_Mueller_en.pdf">english</a>).</p>
<h3 id="logics-and-computer-science">Logics And Computer Science</h3>
<p>Currently I am completing my Master’s degree in logics (University Leipzig) writing my thesis about the <a href="https://en.wikipedia.org/wiki/Lambda_calculus">lambda calculus</a>. a mathematical device invented in the 1930s by Alonzo Church to explore the concept of computability. The lambda calculus played a crucial rule in solving Hilbert’s <a href="https://en.wikipedia.org/wiki/Entscheidungsproblem">Entscheidungsproblem</a> and it is still one of the most valuable and versatile formal tools. It can be regarded as a paradigmatic programming language that lays the foundation for functional languages like Haskell, Lisp, Scala, OCaml and many others. Moreover, it is an important tool to investigate and formalize the semantics of programming languages in general.</p>
<p>Besides poring over books about lambda calculus and type theory I enjoy writing code in the purely functional language Haskell and (functional) programming in general. In addition I enjoy formal verification via SAT/SMT solvers or proof assistants based on the Curry-Howard-isomorphism like Coq.</p>
<h3 id="mechanical-engineering">Mechanical Engineering</h3>
<p>I graduated as a B.E. in Mechanical Engineering from the RFH Köln (Cologne). During my curriculum I worked about two years in the R&amp;D department of <a href="https://www.herrenknecht.com/en/home.html">Herrenknecht AG</a>, the world leader in building tunnel boring machines. First I came to Herrenknecht as an intern, later for writing my Bachelor thesis, before working as an employed student to finish the project. This was a great time and I learned a lot along the way: I had the opportunity to contribute to many interesting projects from pattern recognition in image data to designing prototypes for nuclear research facilities.</p>
 <footer>
  <p id="contact">Get in touch with me:<a href="mailto:@example.com">
  jul.mue@hotmail.de</a>.</p>
</footer>
</body>
</html>
